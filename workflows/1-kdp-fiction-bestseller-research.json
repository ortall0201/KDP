{
  "name": "KDP Fiction Best Seller Research",
  "nodes": [
    {
      "parameters": {},
      "id": "1",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "// Fiction categories to research\n// EDIT THIS LIST to focus on categories you want\nconst categories = [\n  { name: 'Romance', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Romance-eBooks/zgbs/digital-text/158566011' },\n  { name: 'Billionaire Romance', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Billionaire-Romance-eBooks/zgbs/digital-text/8112918011' },\n  { name: 'Small Town Romance', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Small-Town-Country-Romance-eBooks/zgbs/digital-text/6361474011' },\n  { name: 'Paranormal Romance', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Paranormal-Romance-eBooks/zgbs/digital-text/158568011' },\n  { name: 'Thriller', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Thrillers-eBooks/zgbs/digital-text/155006011' },\n  { name: 'Mystery', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Mystery-eBooks/zgbs/digital-text/157028011' },\n  { name: 'Fantasy', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Fantasy-eBooks/zgbs/digital-text/158574011' },\n  { name: 'Urban Fantasy', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Urban-Fantasy-eBooks/zgbs/digital-text/6487426011' },\n  { name: 'Sci-Fi', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-Science-Fiction-eBooks/zgbs/digital-text/156449011' },\n  { name: 'LitRPG', url: 'https://www.amazon.com/Best-Sellers-Kindle-Store-LitRPG-eBooks/zgbs/digital-text/20729661011' }\n];\n\nreturn categories.map(cat => ({\n  json: { \n    category: cat.name,\n    url: cat.url\n  }\n}));"
      },
      "id": "2",
      "name": "Fiction Categories (EDIT THIS)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.9"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br"
            },
            {
              "name": "Referer",
              "value": "https://www.amazon.com/"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Upgrade-Insecure-Requests",
              "value": "1"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "document"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "navigate"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=0"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": true
            }
          }
        }
      },
      "id": "3",
      "name": "Fetch Best Seller Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract best seller data from Amazon HTML\nconst response = $input.item.json;\nconst category = $('Fiction Categories (EDIT THIS)').item.json.category;\n\nconst statusCode = response.statusCode || 0;\nlet html = '';\n\nif (response.data) {\n  html = String(response.data);\n} else if (response.body) {\n  html = String(response.body);\n} else {\n  html = String(response);\n}\n\nif (statusCode !== 200 || html.length < 5000) {\n  return {\n    json: {\n      category: category,\n      error: `HTTP ${statusCode} or HTML too short`,\n      skip: true\n    }\n  };\n}\n\n// Extract book data from best seller list\nconst books = [];\n\n// Method 1: Look for product grid items\nconst productRegex = /<div[^>]*class=\"[^\"]*zg-grid-general-faceout[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>\\s*<\\/div>\\s*<\\/div>/gi;\nlet productMatch;\n\nlet bookCount = 0;\nwhile ((productMatch = productRegex.exec(html)) !== null && bookCount < 20) {\n  const productHtml = productMatch[1];\n  \n  // Extract title\n  const titleMatch = productHtml.match(/<div class=\"_cDEzb_p13n-sc-css-line-clamp-1[^\"]*\">([^<]+)<\\/div>/i) ||\n                    productHtml.match(/alt=\"([^\"]+)\"/i);\n  const title = titleMatch ? titleMatch[1].trim() : 'Unknown';\n  \n  // Skip if no real title\n  if (title === 'Unknown' || title.length < 5) continue;\n  \n  // Extract author\n  const authorMatch = productHtml.match(/<a[^>]*class=\"[^\"]*a-size-small[^\"]*\"[^>]*>([^<]+)<\\/a>/i) ||\n                     productHtml.match(/<div class=\"a-row a-size-small\">\\s*<span[^>]*>([^<]+)<\\/span>/i);\n  const author = authorMatch ? authorMatch[1].trim() : 'Unknown';\n  \n  // Extract price\n  const priceMatch = productHtml.match(/\\$([0-9]+\\.[0-9]{2})/i);\n  const price = priceMatch ? parseFloat(priceMatch[1]) : 0;\n  \n  // Extract rating\n  const ratingMatch = productHtml.match(/([0-9]\\.[0-9]) out of 5 stars/i) ||\n                     productHtml.match(/title=\"([0-9]\\.[0-9]) out of 5 stars\"/i);\n  const rating = ratingMatch ? parseFloat(ratingMatch[1]) : 0;\n  \n  // Extract review count\n  const reviewMatch = productHtml.match(/(\\d{1,3}(?:,\\d{3})*)</i);\n  const reviews = reviewMatch ? parseInt(reviewMatch[1].replace(/,/g, '')) : 0;\n  \n  // Extract rank (position in list)\n  const rankMatch = productHtml.match(/#(\\d+)/i);\n  const rank = rankMatch ? parseInt(rankMatch[1]) : bookCount + 1;\n  \n  // Extract ASIN (Amazon ID)\n  const asinMatch = productHtml.match(/\\/dp\\/([A-Z0-9]{10})/i) ||\n                   productHtml.match(/data-asin=\"([A-Z0-9]{10})\"/i);\n  const asin = asinMatch ? asinMatch[1] : null;\n  \n  if (title && title !== 'Unknown') {\n    books.push({\n      rank: rank,\n      title: title,\n      author: author,\n      price: price,\n      rating: rating,\n      reviews: reviews,\n      asin: asin,\n      amazon_url: asin ? `https://www.amazon.com/dp/${asin}` : null\n    });\n    bookCount++;\n  }\n}\n\n// If method 1 didn't work, try method 2: simpler pattern matching\nif (books.length === 0) {\n  // Try to find titles anywhere in HTML\n  const titlePattern = /<div class=\"_cDEzb_p13n-sc-css-line-clamp-[^\"]+\">([^<]+)<\\/div>/gi;\n  const titles = [];\n  let titleMatch2;\n  while ((titleMatch2 = titlePattern.exec(html)) !== null && titles.length < 20) {\n    titles.push(titleMatch2[1].trim());\n  }\n  \n  // Extract prices\n  const pricePattern = /<span class=\"_cDEzb_p13n-sc-price[^>]*>\\$([0-9]+\\.[0-9]{2})<\\/span>/gi;\n  const prices = [];\n  let priceMatch2;\n  while ((priceMatch2 = pricePattern.exec(html)) !== null && prices.length < 20) {\n    prices.push(parseFloat(priceMatch2[1]));\n  }\n  \n  // Extract ratings\n  const ratingPattern = /([0-9]\\.[0-9]) out of 5 stars/gi;\n  const ratings = [];\n  let ratingMatch2;\n  while ((ratingMatch2 = ratingPattern.exec(html)) !== null && ratings.length < 20) {\n    ratings.push(parseFloat(ratingMatch2[1]));\n  }\n  \n  // Combine what we found\n  const maxLength = Math.max(titles.length, prices.length, ratings.length);\n  for (let i = 0; i < maxLength && i < 20; i++) {\n    books.push({\n      rank: i + 1,\n      title: titles[i] || 'Unknown',\n      author: 'Unknown',\n      price: prices[i] || 0,\n      rating: ratings[i] || 0,\n      reviews: 0,\n      asin: null,\n      amazon_url: null\n    });\n  }\n}\n\nif (books.length === 0) {\n  return {\n    json: {\n      category: category,\n      error: 'Could not extract book data from best seller page',\n      html_length: html.length,\n      has_product_divs: html.includes('zg-grid-general-faceout'),\n      has_price_spans: html.includes('_cDEzb_p13n-sc-price'),\n      skip: true\n    }\n  };\n}\n\n// Calculate statistics\nconst avgPrice = books.filter(b => b.price > 0).reduce((sum, b) => sum + b.price, 0) / books.filter(b => b.price > 0).length || 0;\nconst avgRating = books.filter(b => b.rating > 0).reduce((sum, b) => sum + b.rating, 0) / books.filter(b => b.rating > 0).length || 0;\nconst avgReviews = books.filter(b => b.reviews > 0).reduce((sum, b) => sum + b.reviews, 0) / books.filter(b => b.reviews > 0).length || 0;\n\n// Analyze title patterns\nconst titleWords = {};\nbooks.forEach(book => {\n  const words = book.title.toLowerCase().split(/\\s+/);\n  words.forEach(word => {\n    if (word.length > 3) {\n      titleWords[word] = (titleWords[word] || 0) + 1;\n    }\n  });\n});\n\n// Get top 10 common words\nconst commonWords = Object.entries(titleWords)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 10)\n  .map(([word, count]) => ({ word, count }));\n\nreturn {\n  json: {\n    category: category,\n    books_found: books.length,\n    books: books,\n    statistics: {\n      avg_price: avgPrice,\n      avg_rating: avgRating,\n      avg_reviews: avgReviews,\n      price_range: {\n        min: Math.min(...books.filter(b => b.price > 0).map(b => b.price)),\n        max: Math.max(...books.filter(b => b.price > 0).map(b => b.price))\n      }\n    },\n    title_patterns: commonWords,\n    timestamp: new Date().toISOString(),\n    skip: false\n  }\n};"
      },
      "id": "4",
      "name": "Extract Best Seller Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.skip }}",
              "value2": false
            }
          ]
        }
      },
      "id": "5",
      "name": "Skip Failed Extractions",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "const allCategories = $input.all();\n\nif (allCategories.length === 0) {\n  return { json: { skip: true, message: 'No data extracted' } };\n}\n\nconst now = new Date();\nconst timestamp = now.toISOString().replace(/[:.]/g, '-').substring(0, 19);\n\nlet markdown = '# KDP Fiction Best Seller Analysis\\n\\n';\nmarkdown += '**Generated:** ' + timestamp + '\\n';\nmarkdown += '**Categories Analyzed:** ' + allCategories.length + '\\n\\n';\nmarkdown += '---\\n\\n';\n\nallCategories.forEach((item, index) => {\n  const data = item.json;\n  \n  markdown += '## ' + (index + 1) + '. ' + data.category + '\\n\\n';\n  \n  markdown += '### Market Statistics\\n\\n';\n  markdown += '- **Books Analyzed:** ' + data.books_found + '\\n';\n  markdown += '- **Avg Price:** $' + (data.statistics.avg_price || 0).toFixed(2);\n  markdown += ' (range: $' + (data.statistics.price_range.min || 0).toFixed(2) + ' - $' + (data.statistics.price_range.max || 0).toFixed(2) + ')\\n';\n  markdown += '- **Avg Rating:** ' + (data.statistics.avg_rating || 0).toFixed(2) + ' stars\\n';\n  markdown += '- **Avg Reviews:** ' + Math.round(data.statistics.avg_reviews || 0).toLocaleString() + '\\n\\n';\n  \n  markdown += '### Common Title Patterns\\n\\n';\n  if (data.title_patterns && data.title_patterns.length > 0) {\n    markdown += 'Words appearing most in best seller titles:\\n\\n';\n    data.title_patterns.forEach(pattern => {\n      markdown += '- **' + pattern.word + '** (appears in ' + pattern.count + ' titles)\\n';\n    });\n  }\n  markdown += '\\n';\n  \n  markdown += '### Top 10 Best Sellers\\n\\n';\n  if (data.books && Array.isArray(data.books)) {\n    const top10 = data.books.slice(0, 10);\n    top10.forEach(book => {\n      markdown += '#### #' + book.rank + ': ' + book.title + '\\n\\n';\n      if (book.author && book.author !== 'Unknown') {\n        markdown += '- **Author:** ' + book.author + '\\n';\n      }\n      if (book.price > 0) {\n        markdown += '- **Price:** $' + book.price.toFixed(2) + '\\n';\n      }\n      if (book.rating > 0) {\n        markdown += '- **Rating:** ' + book.rating.toFixed(1) + ' stars';\n        if (book.reviews > 0) {\n          markdown += ' (' + book.reviews.toLocaleString() + ' reviews)';\n        }\n        markdown += '\\n';\n      }\n      if (book.amazon_url) {\n        markdown += '- **Link:** ' + book.amazon_url + '\\n';\n      }\n      markdown += '\\n';\n    });\n  }\n  \n  markdown += '---\\n\\n';\n});\n\nmarkdown += '\\n## Next Steps\\n\\n';\nmarkdown += '1. Choose a category with good stats (avg rating 4.0-4.5, decent reviews)\\n';\nmarkdown += '2. Study the top 10 titles and descriptions\\n';\nmarkdown += '3. Create a similar book concept\\n';\nmarkdown += '4. Use Workflow 2 to generate the manuscript with AI\\n';\nmarkdown += '5. Send to Upwork editor for polish\\n';\nmarkdown += '6. Design cover mimicking best seller styles\\n';\nmarkdown += '7. Launch free → gather reviews → add price\\n\\n';\nmarkdown += '*Data extracted from Amazon best seller lists.*\\n';\n\nconst fileName = 'fiction_bestsellers_' + timestamp + '.md';\nconst filePath = 'books/research/' + fileName;\n\nreturn {\n  json: {\n    file_path: filePath,\n    file_name: fileName,\n    markdown_content: markdown,\n    categories_analyzed: allCategories.length,\n    timestamp: timestamp,\n    skip: false\n  }\n};"
      },
      "id": "6",
      "name": "Compile Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.skip }}",
              "value2": false
            }
          ]
        }
      },
      "id": "7",
      "name": "Skip If Empty",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "resource": "file",
        "operation": "create",
        "owner": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "repository": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "filePath": "={{ $json.file_path }}",
        "fileContent": "={{ $json.markdown_content }}",
        "commitMessage": "=Add fiction best seller research: {{ $json.categories_analyzed }} categories",
        "additionalParameters": {}
      },
      "id": "8",
      "name": "Commit to GitHub",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1,
      "position": [1780, 300]
    }
  ],
  "connections": {
    "Manual Trigger": {"main": [[{"node": "Fiction Categories (EDIT THIS)", "type": "main", "index": 0}]]},
    "Fiction Categories (EDIT THIS)": {"main": [[{"node": "Fetch Best Seller Page", "type": "main", "index": 0}]]},
    "Fetch Best Seller Page": {"main": [[{"node": "Extract Best Seller Data", "type": "main", "index": 0}]]},
    "Extract Best Seller Data": {"main": [[{"node": "Skip Failed Extractions", "type": "main", "index": 0}]]},
    "Skip Failed Extractions": {"main": [[{"node": "Compile Report", "type": "main", "index": 0}]]},
    "Compile Report": {"main": [[{"node": "Skip If Empty", "type": "main", "index": 0}]]},
    "Skip If Empty": {"main": [[{"node": "Commit to GitHub", "type": "main", "index": 0}]]}
  },
  "settings": {"executionOrder": "v1"}
}
